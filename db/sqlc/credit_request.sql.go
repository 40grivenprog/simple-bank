// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: credit_request.sql

package db

import (
	"context"
	"database/sql"
)

const cancelCreditRequestById = `-- name: CancelCreditRequestById :one
UPDATE credit_requests
SET status = 'cancelled'
WHERE id = $1
RETURNING id, status, amount, reason, username, currency, created_at
`

func (q *Queries) CancelCreditRequestById(ctx context.Context, id int64) (CreditRequest, error) {
	row := q.db.QueryRowContext(ctx, cancelCreditRequestById, id)
	var i CreditRequest
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Amount,
		&i.Reason,
		&i.Username,
		&i.Currency,
		&i.CreatedAt,
	)
	return i, err
}

const createCreditRequest = `-- name: CreateCreditRequest :one
INSERT INTO credit_requests (
  username,
  reason,
  amount,
  currency
)
VALUES (
  $1, $2, $3, $4
) RETURNING id, status, amount, reason, username, currency, created_at
`

type CreateCreditRequestParams struct {
	Username string         `json:"username"`
	Reason   sql.NullString `json:"reason"`
	Amount   int32          `json:"amount"`
	Currency string         `json:"currency"`
}

func (q *Queries) CreateCreditRequest(ctx context.Context, arg CreateCreditRequestParams) (CreditRequest, error) {
	row := q.db.QueryRowContext(ctx, createCreditRequest,
		arg.Username,
		arg.Reason,
		arg.Amount,
		arg.Currency,
	)
	var i CreditRequest
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Amount,
		&i.Reason,
		&i.Username,
		&i.Currency,
		&i.CreatedAt,
	)
	return i, err
}

const getCreditRequestsByUsername = `-- name: GetCreditRequestsByUsername :many
SELECT id, status, amount, reason, username, currency, created_at FROM credit_requests
WHERE username = $1
`

func (q *Queries) GetCreditRequestsByUsername(ctx context.Context, username string) ([]CreditRequest, error) {
	rows, err := q.db.QueryContext(ctx, getCreditRequestsByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CreditRequest{}
	for rows.Next() {
		var i CreditRequest
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Amount,
			&i.Reason,
			&i.Username,
			&i.Currency,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingCreditRequestById = `-- name: GetPendingCreditRequestById :one
SELECT id, status, amount, reason, username, currency, created_at FROM credit_requests
WHERE id = $1 and status = 'pending'
`

func (q *Queries) GetPendingCreditRequestById(ctx context.Context, id int64) (CreditRequest, error) {
	row := q.db.QueryRowContext(ctx, getPendingCreditRequestById, id)
	var i CreditRequest
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Amount,
		&i.Reason,
		&i.Username,
		&i.Currency,
		&i.CreatedAt,
	)
	return i, err
}

const getUsersPendingCreditRequests = `-- name: GetUsersPendingCreditRequests :many
SELECT id, status, amount, reason, username, currency, created_at FROM credit_requests
WHERE status = 'pending'
`

func (q *Queries) GetUsersPendingCreditRequests(ctx context.Context) ([]CreditRequest, error) {
	rows, err := q.db.QueryContext(ctx, getUsersPendingCreditRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CreditRequest{}
	for rows.Next() {
		var i CreditRequest
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Amount,
			&i.Reason,
			&i.Username,
			&i.Currency,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
